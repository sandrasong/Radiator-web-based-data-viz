<!DOCTYPE html>
<meta charset="utf-8">
<style>

body{
    width:1060px;
    margin:50px auto;
}

path {  stroke: #fff; }
path:hover {  opacity:0.9; }
rect:hover {  opacity: 0.7; }
.axis {  font: 10px sans-serif; }
.legend tr{    border-bottom:1px #B9B9B8; }
.legend tr:first-child{    border-top:1px #B9B9B8; }

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {  display: none; }
.legend{
    margin-bottom:76px;
    display:inline-block;
    border-collapse: collapse;
    border-spacing: 0px;
}
.legend td{
    padding:4px 5px;
    vertical-align:bottom;
}
.legendFreq, .legendPerc{
    align:right;
    width:50px;
}
body {
    font-family: sans-serif;
}

#centerMe{
    text-align: center;

}

</style>

<body>
 <h1>Monthly Building Temperature Performance</h1>
 <p>780 5th Ave, Brooklyn, NY 11232</p>
 <div id='dashboard'></div>
 <p>Floors</p>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

d3.json("monthly.json", function (error, root)
    {
        if (error) throw error;
        dashboard('#dashboard',root);
    });

function dashboard(id, fData){
    var barColor = '#85c07d';
    function segColor(c){ return {cold:"#98cae4", comfortable:"#e4ecd8",hot:"#e0c0bb"}[c]; }

    
    // compute total for each state.
    // this is taking the total of low, mid, high and making it the height of the bar and appending to document

    var floor1 = [],
        floor2 = [],
        floor3 = [],
        floor4 = [],
        floor5 = [],
        floor6 = [];

   fData.forEach(function(d){
        if(d.floor == 6)  
            {
                floor6.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 5)   
            {
                floor5.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 4)   
            {
                floor4.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 3)   
            {
                floor3.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 2)   
            {
                floor2.push({"apartment": d.apartment, "temp": d.temp});
            }
            else 
            {
                floor1.push({"apartment": d.apartment, "temp": d.temp});
            }
    });


   console.log(floor6); 

    var allMean = [];
       sum6 =0,
       sum5 =0,
       sum4 =0,
       sum3 =0,
       sum2 =0,
       sum1 =0;
//calculate mean value of floor 6
    for (i=0;i<floor6.length;i++){
    sum6 +=floor6[i].temp;
    }
    floor6.mean = sum6/floor6.length;

//calculate mean value of floor 5
    for (i=0;i<floor5.length;i++){
    sum5 +=floor5[i].temp;
    }
    floor5.mean = sum5/floor5.length;

//calculate mean value of floor 4
    for (i=0;i<floor4.length;i++){
    sum4 +=floor4[i].temp;
    }
    floor4.mean = sum4/floor4.length;

//calculate mean value of floor 3
    for (i=0;i<floor3.length;i++){
    sum3 +=floor3[i].temp;
    }
    floor3.mean = sum3/floor3.length;

//calculate mean value of floor 2
    for (i=0;i<floor2.length;i++){
        sum2 +=floor2[i].temp;
    }
    floor2.mean = sum2/floor2.length;

//calculate mean value of floor 1
    for (i=0;i<floor1.length;i++){
        sum1 +=floor1[i].temp;
    }
    floor1.mean = sum1/floor1.length;
    allMean = [[1,floor1.mean], [2,floor2.mean],[3,floor3.mean],[4,floor4.mean],[5,floor5.mean],[6,floor6.mean]];
    console.log(allMean);
    var hG = histoGram(allMean); // create the histogram.
        
    // function to handle histogram.
    function histoGram(fD){
        var hG={},    
        hGDim = {t: 60, r: 0, b: 30, l: 0};
        hGDim.w = 500 - hGDim.l - hGDim.r, 
        hGDim.h = 300 - hGDim.t - hGDim.b;
            
        //create svg for histogram.
        var hGsvg = d3.select(id).append("svg")
            .attr("width", hGDim.w + hGDim.l + hGDim.r)
            .attr("height", hGDim.h + hGDim.t + hGDim.b).append("g")
            .attr("transform", "translate(" + hGDim.l + "," + hGDim.t + ")");

        // create function for x-axis mapping.
        var x = d3.scale.ordinal().rangeRoundBands([0, hGDim.w], 0.1)
                .domain(fD.map(function(d) { return d[0];}));  
        //fD.map result is ["Floor1", "Floor2", "Floor3", "Floor4", "Floor5", "Floor6"]
        

        // Add x-axis to the histogram svg.
        hGsvg.append("g").attr("class", "x axis")
            .attr("transform", "translate(0," + hGDim.h + ")")
            .call(d3.svg.axis().scale(x).orient("bottom"));

        // Create function for y-axis map.
        var y = d3.scale.linear().range([hGDim.h, 0])
                .domain([0, d3.max(fD, function(d) { return d[1]; })]); 
       // console.log(d3.max(fD, function(d) { return d[1]; }));

        // Create bars for histogram to contain rectangles and freq labels.
        var bars = hGsvg.selectAll(".bar").data(fD).enter()
                .append("g").attr("class", "bar");
        
        //create the rectangles.
        bars.append("rect")
            .attr("x", function(d) { return x(d[0]); })
            .attr("y", function(d) { return y(d[1]); })
            .attr("width", x.rangeBand())
            .attr("height", function(d) { return hGDim.h - y(d[1]); })
            .attr('fill',barColor)
            .on("mouseover",mouseover)// mouseover is defined below.
            .on("mouseout",mouseout);// mouseout is defined below.
            
        //Create the frequency labels above the rectangles.
        //format the text above the bar
        bars.append("text").text(function(d){ return Math.round(d3.format(",")(d[1])) + " Â°F"})  //d[1] is the frequency
            .attr("x", function(d) { return x(d[0])+x.rangeBand()/2; })
            .attr("y", function(d) { return y(d[1])-5; })
            .attr("text-anchor", "middle");
        
        function mouseover(d){  
        // utility function to be called on mouseover.
            // filter for selected floor.
            console.log(d);

            var st = fData.filter(function(s) {return s.floor == d[0];}),  
            //d[0] are strings but s.floor are numbers
                lowRoomsCount = (st.filter(function(d) {return d.temp <= 72;})).length,
                highRoomsCount = (st.filter(function(d) {return d.temp >= 80;})).length,
                midRoomsCount = (st.filter(function(d) {return 72<d.temp < 80;})).length;

                nD = [{roomtype: "cold", time: lowRoomsCount},{roomtype: "comfortable", time: midRoomsCount},{roomtype: "hot", time: highRoomsCount}]; //d3.keys(st.temp);
                console.log(st);
                console.log(nD);

            // call update functions of pie-chart and legend.    
            pC.update(nD);
            leg.update(nD);
        }
        
        function mouseout(d){    // utility function to be called on mouseout.
            // reset the pie-chart and legend.    
            pC.update(tT);
            leg.update(tT);
        }
       
        return hG;
    }


var lowRooms = fData.filter(function(d) {return d.temp <= 72;}),
    highRooms = fData.filter(function(d) {return d.temp >= 80;}),
    midRooms = fData.filter(function(d) {return 72<d.temp < 80;});

    
    console.log(lowRooms.length);
    console.log(highRooms.length);
    console.log(midRooms.length);

var tT =[{roomtype: "cold", time: lowRooms.length},{roomtype: "comfortable", time: midRooms.length},{roomtype: "hot", time: highRooms.length}];

console.log(tT);

    var pC = pieChart(tT),
        leg = legend(tT);
    // function to handle pieChart.
    function pieChart(pD){
        var pC ={},    
        pieDim ={w:250, h: 250};
        pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;
                
        // create svg for pie chart.
        var piesvg = d3.select(id).append("svg")
            .attr("width", pieDim.w)
            .attr("height", pieDim.h).append("g")
            .attr("transform", "translate("+pieDim.w/2+","+pieDim.h/2+")");
        
        // create function to draw the arcs of the pie slices.
        var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0);

        // create a function to compute the pie slice angles.
        var pie = d3.layout.pie().sort(null).value(function(d) { return d.time; });

        // Draw the pie slices.
        piesvg.selectAll("path")
            .data(pie(pD))
            .enter().append("path")
            .attr("d", arc)
            .each(function(d) { this._current = d; })
            .style("fill", function(d) { 
            return segColor(d.data.roomtype);});              //match colors to percentage 

    
        pC.update = function(nD){
                piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
                .attrTween("d", arcTween);
        }  
        function arcTween(a) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t) { return arc(i(t));    };
        }    
        return pC;
    }
    
    // function to handle legend.
    function legend(lD){
        var leg = {};
            
        // create table for legend.
        var legend = d3.select(id).append("table").attr('class','legend');
        
        // create one row per segment.
        var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr");
            
        // create the first column for each segment.
        tr.append("td").append("svg").attr("width", '16').attr("height", '16').append("rect")
            .attr("width", '16').attr("height", '16')
            .attr("fill",function(d){ return segColor(d.roomtype); });


        tr.append("td").attr("class",'legendPerc')
            .text(function(d){return getPercentage(d,lD);});


        // create the second column for each segment.
         tr.append("td").text(function(d){ return d.roomtype;});

        // Utility function to be used to update the legend.
        leg.update = function(nD){

            var l = legend.select("tbody").selectAll("tr").data(nD);
                console.log(l);

            // update the percentage column.
            l.select(".legendPerc").text(function(d){ return getPercentage(d,nD);});  
          //  legend.select("tbody").selectAll("tr").data(nD).remove();      
        }
        
        function getPercentage(d,aD){ // Utility function to compute percentage.
            return d3.format("%")(d.time/d3.sum(aD.map(function(v){ return v.time; })));
        }
        
        return leg;
    }
   
    
}
</script>

