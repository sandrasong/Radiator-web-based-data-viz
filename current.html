<!DOCTYPE html>
<meta charset="utf-8">
<style>

body{
	float: left;
	width: 100%;
    /*width:1060px;*/
    /*margin:50px auto;*/
}

path {  stroke: #fff; }
path:hover {  opacity:0.9; }
rect:hover {  opacity:0.7; }
.axis {  font: 10px sans-serif; }
.legend tr{    border-bottom:1px solid grey; }
.legend tr:first-child{    border-top:1px solid grey; }

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {  display: none; }
.legend{
    margin-bottom:76px;
    display:inline-block;
    border-collapse: collapse;
    border-spacing: 0px;
}
.legend td{
    padding:4px 5px;
    vertical-align:bottom;
}
.legendFreq, .legendPerc{
    align:right;
    width:50px;
}

body {

font-family: sans-serif;
}

</style>

<body>
    <h1>Current Building Temperature</h1>
    <p>780 5th Ave, Brooklyn, NY 11232</p>
    <p>Blue means cold room, red is hot room and green is good temperature room.</p>
    <p>The default pie chart shows rooms eitgher too hot or too cold. The default bar chart shows the average temperature of every floor. When you mouse over each floor, the pie chart will show each room's temperature performance.</p> 
 <div id='dashboard'></div>
 <div>Floors</div>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

d3.json("current.json", function (error, root)
    {
        if (error) throw error;
        dashboard('#dashboard',root);
    });

function dashboard(id, fData){
    var barColor = '#85c07d';
    function segColor(c){ return {cold:"#98cae4", comfortable:"#E4ECD8",hot:"#e0c0bb"}[c]; }

    
    // compute total for each state.
    // this is taking the total of low, mid, high and making it the height of the bar and appending to document
    //fData.forEach(function(d){d.total=d.freq.low+d.freq.mid+d.freq.high;});

    var floor1 = [],
        floor2 = [],
        floor3 = [],
        floor4 = [],
        floor5 = [],
        floor6 = [];

   fData.forEach(function(d){
        if (d.floor == 6)  
            {
                floor6.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 5)   
            {
                floor5.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 4)   
            {
                floor4.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 3)   
            {
                floor3.push({"apartment": d.apartment, "temp": d.temp});
            }
            else if(d.floor == 2)   
            {
                floor2.push({"apartment": d.apartment, "temp": d.temp});
            }
            else 
            {
                floor1.push({"apartment": d.apartment, "temp": d.temp});
            }
    });


   console.log(floor6);
 //  console.log(floor6[0].apartment);

    var allMean = [];
       sum6 =0,
       sum5 =0,
       sum4 =0,
       sum3 =0,
       sum2 =0,
       sum1 =0;
//calculate mean value of floor 6
    for (i=0;i<floor6.length;i++){
    sum6 +=floor6[i].temp;
    }
    floor6.mean = sum6/floor6.length;

//calculate mean value of floor 5
    for (i=0;i<floor5.length;i++){
    sum5 +=floor5[i].temp;
    }
    floor5.mean = sum5/floor5.length;

//calculate mean value of floor 4
    for (i=0;i<floor4.length;i++){
    sum4 +=floor4[i].temp;
    }
    floor4.mean = sum4/floor4.length;

//calculate mean value of floor 3
    for (i=0;i<floor3.length;i++){
    sum3 +=floor3[i].temp;
    }
    floor3.mean = sum3/floor3.length;

//calculate mean value of floor 2
    for (i=0;i<floor2.length;i++){
        sum2 +=floor2[i].temp;
    }
    floor2.mean = sum2/floor2.length;

//calculate mean value of floor 1
    for (i=0;i<floor1.length;i++){
        sum1 +=floor1[i].temp;
    }
    floor1.mean = sum1/floor1.length;
    allMean = [[1,floor1.mean], [2,floor2.mean],[3,floor3.mean],[4,floor4.mean],[5,floor5.mean],[6,floor6.mean]];
    console.log(allMean);
    var hG = histoGram(allMean); // create the histogram.




    var badRooms = fData.filter(function(d) {return d.temp<=72 || d.temp>=80;}).map(function(t){return {room: t.room, temp: t.temp};});
    console.log(badRooms);
    var pC = pieChart(badRooms); // create the pie-chart.
   //     leg= legend(badRooms);  // create the legend.

        
    // function to handle histogram.
    function histoGram(fD){
        var hG={},    
        hGDim = {t: 60, r: 0, b: 30, l: 0};
        hGDim.w = 500 - hGDim.l - hGDim.r, 
        hGDim.h = 300 - hGDim.t - hGDim.b;
            
        //create svg for histogram.
        var hGsvg = d3.select(id).append("svg")
            .attr("width", hGDim.w + hGDim.l + hGDim.r)
            .attr("height", hGDim.h + hGDim.t + hGDim.b).append("g")
            .attr("transform", "translate(" + hGDim.l + "," + hGDim.t + ")");

        // create function for x-axis mapping.
        var x = d3.scale.ordinal().rangeRoundBands([0, hGDim.w], 0.1)
                .domain(fD.map(function(d) { return (d[0]);
                console.log(d[0]);}));  //fD.map result is ["Floor1", "Floor2", "Floor3", "Floor4", "Floor5", "Floor6"]
        //         console.log(fD.map(function(d) { return d[0];}));

        // Add x-axis to the histogram svg.
        hGsvg.append("g").attr("class", "x axis")
            .attr("transform", "translate(0," + hGDim.h + ")")
            .call(d3.svg.axis().scale(x).orient("bottom"));

        // Create function for y-axis map.
        var y = d3.scale.linear().range([hGDim.h, 0])
                .domain([0, d3.max(fD, function(d) { return d[1]; })]); 
       // console.log(d3.max(fD, function(d) { return d[1]; }));

        // Create bars for histogram to contain rectangles and freq labels.
        var bars = hGsvg.selectAll(".bar").data(fD).enter()
                .append("g").attr("class", "bar");
        
        //create the rectangles.
        bars.append("rect")
            .attr("x", function(d) { return x(d[0]); })
            .attr("y", function(d) { return y(d[1]); })
            .attr("width", x.rangeBand())
            .attr("height", function(d) { return hGDim.h - y(d[1]); })
            .attr('fill',barColor)
            .on("mouseover",mouseover)// mouseover is defined below.
            .on("mouseout",mouseout);// mouseout is defined below.
            
        //Create the frequency labels above the rectangles.
        //format the text above the bar
        bars.append("text").text(function(d){ return Math.round(d3.format(",")(d[1])) + "° F"})  //d[1] is the frequency
            .attr("x", function(d) { return x(d[0])+x.rangeBand()/2; })
            .attr("y", function(d) { return y(d[1])-5; })
            .attr("text-anchor", "middle");
        
        function mouseover(d){  // utility function to be called on mouseover.
            // filter for selected floor.
           
            var st = fData.filter(function(s) {return s.floor == d[0];}) ,  //d[0] are strings but s.floor are numbers
                nD = st.map(function(s) {return {room:s.room, temp:s.temp};}); //d3.keys(st.temp);
                console.log(st);
                console.log(nD);

      /*      var st = fData.filter(function(s){ return s.floor == d[0];})[0],     //change State to Floor
                nD = d3.keys(st.freq).map(function(s){ return {type:s, freq:st.freq[s]};});   //change the st.freq to temperature
               console.log(st);   //st = {State: "Floor1",  total: 6354, mean: 2118} when mouseove floor1, the format we need should look like {Floor: "1", {unit: "1A", mean: 70}}
    */
          // floor1, the format we need should look like [{unit: "1A", temp: 70},{unit:"1B", temp: 72}, ...]
            // call update functions of pie-chart and legend.    
            pC.update(nD);
            leg.update(nD);
        }
        
        function mouseout(d){    // utility function to be called on mouseout.
            // reset the pie-chart and legend.    
            pC.update(badRooms);
            leg.update(disData);
        }
        
        // create function to update the bars. This will be used by pie-chart.
       
        return hG;
    }


    
    // function to handle pieChart.
    function pieChart(pD){
        var pC ={},    
        pieDim ={w:250, h: 250};
        pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;
                
        // create svg for pie chart.
        var piesvg = d3.select(id).append("svg")
            .attr("width", pieDim.w)
            .attr("height", pieDim.h)
            .append("g")
            .attr("transform", "translate("+pieDim.w/2+","+pieDim.h/2+")");
        
        // create function to draw the arcs of the pie slices.
        var arc = d3.svg.arc()
            .outerRadius(pieDim.r - 10)
            .innerRadius(0);

        // create a function to compute the pie slice angles.
        var pie = d3.layout.pie()
            .sort(null)
            .value(function(d) { return d.temp; });


        // Draw the pie slices.
           var g= piesvg.selectAll(".arc")
            .data(pie(pD))
            .enter().append("g")
            .attr("class","arc");

            g.append("path")
            .attr("d", arc)
            .each(function(d) { this._current = d; })
            .style("fill", function(d) { 
            if(d.data.temp<72) return segColor("cold"); 
            else if(d.data.temp>80)return segColor("hot");
            else return segColor("comfortable");
            });
                         //match colors to temperature
            g.append("text")
              .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
              .attr("dy", ".35em")
              .style("text-anchor", "middle")
              .text(function(d) { return d.data.room; })
              .attr("font-size","10pt")
    //third version
         // piesvg.selectAll("path")
         //     .data(pie(pD))
         //     .exit().remove();

        // create function to update pie-chart. This will be used by histogram.
        pC.update = function(nD){

            pieDim ={w:250, h: 250};
            pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;
                
        // create svg for pie chart.
       /* var piesvg = d3.select(id).append("svg")
            .attr("width", pieDim.w)
            .attr("height", pieDim.h).append("g")
            .attr("transform", "translate("+pieDim.w/2+","+pieDim.h/2+")"); */
        
        // create function to draw the arcs of the pie slices.
            var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0);

        // create a function to compute the pie slice angles.
            var pie = d3.layout.pie().sort(null).value(function(d) { return d.temp; });
                
//second version
            piesvg.selectAll(".arc").remove();
               // selectAll("path").data(pie(nD)).enter().append("path").attr("d", arc)//transition().duration(500)
                var g= piesvg.selectAll(".arc")
                .data(pie(nD))
                .enter().append("g")
                .attr("class","arc");

                g.append("path")
                .attr("d", arc)
                .each(function(d) { this._current = d; })
                .style("fill", function(d) { 
                if(d.data.temp<72) return segColor("cold"); 
                else if(d.data.temp>80)return segColor("hot");
                else return segColor("comfortable");
                });

            // .each(function(d){this._current = d;})
            // .style("fill", function(d) { 
            // if(d.data.temp<72) return segColor("low"); 
            // else if(d.data.temp>80)return segColor("high");
            // else return segColor("mid");
            //}); 

            g.append("text")
            .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
              .attr("dy", ".35em")
              .style("text-anchor", "middle")
                            .attr("font-size","10pt")

              .text(function(d) { return d.data.room; });

        


       

//original clostest version
       /* piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
                .style("fill", function(d) { 
            if(d.data.temp<72) return segColor("low"); 
            else if(d.data.temp>80)return segColor("high");
            else return segColor("mid");
            })
                .attrTween("d", arcTween);
        }  
           // Animating the pie-slice requiring a custom function which specifies
        // how the intermediate paths should be drawn.
        function arcTween(a) {
            var i = d3.interpolate(this._current, a);
            this._current = i(0);
            return function(t) { return arc(i(t));    };
            */
        }
        return pC;
    }
    var disData = [{roomtype: "cold"}, {roomtype: "comfortable"}, {roomtype: "hot"}];
    leg= legend(disData);
    // function to handle legend.
    function legend(allMean){
        var leg = {};
            console.log(allMean);
        // create table for legend.
        var legend = d3.select(id).append("table").attr('class','legend');
        
        // create one row per segment.
        var tr = legend.append("tbody").selectAll("tr").data(allMean).enter().append("tr");
            
        // create the first column for each segment.
         tr.append("td").append("svg").attr("width", '16').attr("height", '16').append("rect")
             .attr("width", '16').attr("height", '16')
             .attr("fill",function(d) { return segColor(d.roomtype); });
        //     if(d.temp<72) return segColor("low"); 
        //     else if(d.temp>80)return segColor("high");
        //     else return segColor("mid");
        //     });
            
        // create the second column for each segment.
        // tr.append("td").text(function(d){ return Math.round(d.temp);});
                tr.append("td").text(function(d){ return d.roomtype;});
        // // create the third column for each segment.
        // tr.append("td").attr("class",'legendFreq')
        //     .text(function(d){ return "° F";});

        // create the fourth column for each segment.
        // tr.append("td").attr("class",'legendPerc')
        //     .text(function(d){ return getLegend(d,lD);});

        // Utility function to be used to update the legend.
        leg.update = function(nD){

            // var tr = legend.append("tbody").selectAll("tr").data(nD);
            // // update the data attached to the row elements.
            // var l = legend.select("tbody").selectAll("tr").data(nD);

            // update the frequencies.
            // l.select(".legendFreq")
            //   .text(function(d){ return d.temp;}
            //     );

            // update the percentage column.
          //  l.select(".legendPerc").text(function(d){ return getLegend(d,nD);});        
        }
        
        // function getLegend(d,aD){ // Utility function to compute percentage.
        //     return d3.format("%")(d.freq/d3.sum(aD.map(function(v){ return v.temp; })));
        // }

        return leg;
    }
   
    
}
</script>

